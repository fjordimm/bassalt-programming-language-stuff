
//////////////////////////////

///// Passing By Reference /////

/*
Note: passing by reference is not to be confused with reference pointers (represented by `&`).

`int& var`    --> "The declaration of a variable 'var' with type 'reference pointer to int'."
`var&`        --> "The address of a variable 'var'."
`ref int var` --> "The declaration of a variable 'var' with type 'int' that is passed by reference."
`ref var`     --> "Passing a variable 'var' by reference."

While something like `int&& var` is legal, something like `ref ref int var` is illegal and wouldn't make sense.
*/

void Main()
{
	int a = 5;
	DoubleMe(ref a);
	DoubleMeWrapper(ref a);

	int b = 9;
	PrintMe1(ref b!);

	int c = 7;
	PrintMe2(inref c);
	PrintMe2(inref 3);

	int d;
	InitializeMe(outref d);
	InitializeMe(int d2 outref); // You can also declare variables in the function call (but see below)

	/* For outrefs, here is a good convention: */
	/* 1) Declare the function with all the outref parameters at the end. */
	/* 2) Format the function call like so... */
	MakeFibonacciSequence(0, 30, // regular parameters go on one line like normal
		outref int[] result; // 
	);
}

void DoubleMe(ref int v)
{
	v *= 2;
}

void DoubleMeWrapper(ref int v)
{
	// `ref int` is not a type, it is just saying that the parameter is given by reference...
	// ...so, you still have to be explicit when passing it by reference to something else
	DoubleMe(ref v);
}

void PrintMe1(ref int! v)
{
	// Cannot write to `v`
	stdout.println(v);
}

// `v` can be an lvalue or rvalue
void PrintMe2(inref int v)
{
	// Cannot write to `v`
	stdout.println(v);
}

// Whatever you pass into `v` does not need to be initialized
void InitializeMe(outref int v)
{
	// Cannot read the value of `v` before assigning it
	v = 13;
	// By the end of the function, `v` must be assigned to something
}

//////////////////////////////

// TODO: outrefs that can assume the referand has been initialized
// TODO: refs that can't assume the referand has been initialized
