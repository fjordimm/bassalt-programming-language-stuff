
//////////////////////////////

///// Cheat Sheet /////

/*
 int&					reference pointer type (of an int)
 int^					unique pointer type (of an int)
 int*					raw pointer type (of an int)
 sptr<int>				shared pointer type (of an int)
 wptr<int>				weak pointer type (of an int)

 var&					address-of operator, returns a reference pointer
 var@					dereference operator
 new int{1}				new operator, returns a unique pointer
 alloc int{1}			alloc operator, returns a raw pointer
 dealloc var			dealloc operator, frees the object that 'var' points to
 sptr<int>(1)		creates and returns a shared pointer
 var.getWeak()			returns a weak pointer from a shared pointer
*/

//////////////////////////////

///// References Pointers /////

void Main()
{
	int a = 1;
	int b = 2;
	int! c = 3;

	int& r1 = a&;
	println$(r1@); // Prints: 1
	a = 10;
	println$(r1@); // Prints: 10

	int& r2 = a&;
	r2@ = 11; // a is now 11.
	r2 = b&;
	r2@ = 22; // b is now 22.

	r2 = 8; // Illegal, the value of a reference must be either null or a valid memory address.
	r2++; // Illegal, the value of a reference must be either null or a valid memory address.

	int&! r3 = a&;
	r3@ = 111; // a is now 111.
	r3 = b&; // Illegal, r3 is fixed.

	int!& r4 = a&;
	r4@ = 1111; // Illegal, r4 is a reference to a fixed int, so r4 can only read from what its pointing to.
	println$(r4@);
	baboei
	r4 = b&; // The value of r4 can still be changed.
	println$(r4@);

	// Think of fixedness as polymorphism. Unfixed types (e.g. int) are subsets of fixed types (e.g. int!).
	int!& r5 = a&;
	int!& r6 = c&;
	int& r6 = a&;
	int& r7 = c&; // Illegal, r7 can mutate what it points to, so it cannot point to a fixed type.

	int!&! r8 = a&;
	println$(r8@);
	r8@ = 100; // Illegal, r8 points to a fixed type.
	r8 = b&; // Illegal, r8 is fixed.

	///////////

	int!&! r9;
	// ...can be rewritten as...
	int&!! r10;
	// You can call this variable immutable, since the '!!' guarantees fixedness recursively, as shown below...
	
	int!&!&!&!&!&! r11;
	// ...can be rewritten as...
	int&&&&&!! r12;

	///////////

	int& r13 = null;
	println$(r13@); // Runtime error.
	r13@ = 1000; // Runtime error.

	int& r14 = a&;
	int& r15 = a&;
	int& r16 = b&;
	int& r17 = null;
	println$(r14 == a&); // Prints: true
	println$(r14 == r15); // Prints: true
	println$(r14 == r16); // Prints: false
	println$(r17 == null);
	r14 = null;
	println$(r14 == r17); // Prints: true
}

//////////////////////////////

///// Unique Pointers /////

void Main()
{
	/* Unique pointers point to objects on the heap. */
	/* When the unique pointer variable goes out of scope, the object it points to is automatically freed. */
	/* Each object on the heap can only be pointed to by one unique pointer at a time. */

	///////////

	int^ up1 = new int{7};
	println$(up1@); // Prints: 7
	up1@ = 8;
	println$(up1@); // Prints: 8

	int^ up2 = new int{3};
	int^ up3 = new int{3};
	println$(up2 == up3); // Prints: false
	println$(up2@ == up3@); // Prints: true

	int^ up4 = new int{9};
	println$(up4@); // Prints: 9
	int^ up5 = up4; // Illegal.
	int^ up5 = cede up4; // up4 has now given ownership of the object to up5.
	println$(up5@); // Prints: 9
	println$(up4@); // Runtime error (null pointer).
	println$(up4 == null); // Prints: true

	///////////

	// The same thing applies about '!!' as for shared references.
	int!^! up6;
	// ...can be rewritten as...
	int^!! up7;
	// ...and...
	int!^!^!^!^!^! up8;
	// ...can be rewritten as...
	int^^^^^!! up9;
}

//////////////////////////////

///// Raw Pointers /////

void Main() unsafe
{
	/* Raw pointers can point to anything on the stack or heap. */
	/* They will not automatically free themselves, so you must free them manually when needed using 'dealloc'. */
	/* Therefore, raw pointers must be used in an unsafe context. */
	/* Mutability/face rules still apply to raw pointers, however. */

	///////////

	int* rp1 = alloc int{7};
	println$(rp1@); // Prints: 7
	rp1@ = 8;
	println$(rp1@); // Prints: 8
	dealloc rp1;

	int* rp2 = alloc int{3};
	int* rp3 = alloc int{3};
	println$(rp2 == rp3); // Prints: false
	println$(rp2@ == rp3@); // Prints: true
	dealloc rp2;
	dealloc rp3;

	int* rp4 = alloc int{9};
	println$(rp4@); // Prints: 9
	int* rp5 = rp4;
	println$(rp5@); // Prints: 9
	println$(rp4@); // Prints: 9
	println$(rp4 == null); // Prints: false
	dealloc rp4;
	println$(rp5 == null); // Prints: false
	println$(rp4@); // Undefined behavior, dereferencing a dangling pointer
	println$(rp5@); // Undefined behavior, dereferencing a dangling pointer

	///////////
}

//////////////////////////////

// TODO: explicit casting from one pointer type to another (e.g. `int* rp = (*)someUniquePtr` and that is actually a shortcut for `int* rp = (int*)someUniquePtr`)
// TODO: combining them (e.g. int^*)
// TODO: equality between them
// TODO: new Point{Point::Origin} vs new Point(0, 0)
// TODO: shared references can only work if they don't have a higher scope than what they point to
